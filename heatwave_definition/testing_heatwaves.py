='''This script will be used to define heatwaves using the max, EHF, and Pezza definition approaches. For analysis of these, refer to moisture comparison.'''# Import all other packagesimport osimport pandas as pdfrom matplotlib import pyplot as pltos.chdir("/Users/marleeyork/Documents/project2/preprocessing")from load_data import *os.chdir("/Users/marleeyork/Documents/project2/heatwave_definition")from define_heatwaves import *from overlapping_heatwaves import *import picklefrom collections import Counter# Print all columnspd.set_option('display.max_columns',None)# pd.set_option('display.max_rows',None) # be careful with this, can back up system# Load adjusted climatological datahistorical_data = pd.read_csv("/Users/marleeyork/Documents/project2/data/cleaned/historical_data_adjusted.csv")historical_data = historical_data.iloc[:,1:]historical_data.date = pd.to_datetime(historical_data.date)# Load in the daily dataAMF_DD = pd.read_csv("/Users/marleeyork/Documents/project2/data/cleaned/AMF_DD.csv")AMF_DD = AMF_DD.iloc[:,1:]AMF_DD.date = pd.to_datetime(AMF_DD.date)# Load in the hourly dataAMF_HH = pd.read_csv("/Users/marleeyork/Documents/project2/data/cleaned/AMF_HH.csv")AMF_HH = AMF_HH.iloc[:,1:]AMF_HH.TIMESTAMP_START = pd.to_datetime(AMF_HH.TIMESTAMP_START)# Get the daily temperature quality control flagsta = loadAMF(path="/Users/marleeyork/Documents/project2/data/AMFdataDD",                 skip = [''],measures=['TIMESTAMP','TA_F','TA_F_QC'])# Get the hourly temperature quality control flagsta_HH = loadAMF(path="/Users/marleeyork/Documents/project2/data/AMFdata_HH",                 skip = [''],measures=['TIMESTAMP_START','TA_F','TA_F_QC'])## Load in the SWC data# Check what sites have swcshared_swc = find_shared_variables(path="/Users/marleeyork/Documents/project2/data/AMFdataDD",measures=['SWC_F_MDS_1'])sites_wo_swc = list(shared_swc['site_presence'][shared_swc['site_presence'].SWC_F_MDS_1==0].Site)swc_data = loadAMF(path="/Users/marleeyork/Documents/project2/data/AMFdataDD",                   skip=sites_wo_swc,measures=['TIMESTAMP','SWC_F_MDS_1'])# Load in precipitation dataprec_data = loadAMF(path="/Users/marleeyork/Documents/project2/data/AMFdataDD",                    skip=sites_wo_swc,measures=['TIMESTAMP','P_F'])#################################################################################                                  MAX                                      #################################################################################'''The following code will fit heatwaves using the maximum approach discussed in Perkins and Alexander. It uses the max temperature for each day and comparesit to a quantile of historical maximum temperature over a certain moving window.I use the parameters most commonly used across the literature (e.g. 15 day movingaverage, 90th quantile, tolerance, etc). The daily max temperatures (not historical ones) are calculated using flux tower data at the hourly interval, thuswe use hourly data as the timeseries input in fit_heatwaves. This is differentfor other approaches!'''# I am going to create a tmax based on the timeseries data that I can use in # replacement of PRISM tmax temporarily as historical data. This will change when # I get the PRISM data for all 45 sites# Initialize empty dictionaryheatwaves = {}for site in swc_data.Site.unique():    print(site)    # Isolate site of interest in climatological and AMF data    flux_data = AMF_HH[AMF_HH['Site']==site]    historical_site_data = historical_data[historical_data['Site']==site][['date','hist_max_adj']]    site_precip = prec_data[prec_data['Site']==site].copy()    site_swc = swc_data[swc_data['Site']==site].copy()        # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(                      flux_dates = flux_data.TIMESTAMP_START, # should be hourly                      flux_temperature = flux_data.TA_F, # should be hourly                      historical_dates = historical_site_data['date'],                       historical_temperature = historical_site_data['hist_max_adj'],                      quantile_threshold = .95,                      window_length = 15,                      threshold_comparison = 'greater',                      min_heatwave_length = 3,                      tolerance = 1,                      gap_days_window = 8,                      site = site,                      method = "max"                      )        # Getting precipitation conditions    if site_heatwaves is None:        continue        else:        site_heatwave_precip = calculate_moisture(            timeseries_dates = site_precip.TIMESTAMP,            timeseries_moisture = site_precip.P_F,            start_dates = site_heatwaves['start_dates'],            end_dates = site_heatwaves['end_dates']            )        site_heatwave_swc = calculate_moisture(            timeseries_dates = site_swc.TIMESTAMP,            timeseries_moisture = site_swc.SWC_F_MDS_1,            start_dates = site_heatwaves['start_dates'],            end_dates = site_heatwaves['end_dates']            )    # Add heatwaves into a dictionary with their site    heatwaves[site] = site_heatwaves    heatwaves[site]['precip'] = site_heatwave_precip    heatwaves[site]['swc'] = site_heatwave_swc    # Create a dataframe of the quality flag for each heatwave at each siteheatwaves_qaqc = pd.DataFrame(columns=['start_dates','end_dates','duration','magnitude','QAQC_flag'])for site in list(heatwaves.keys()):    print(site)    # Retrieve the heatwave dictionary for that site    site_heatwave_dictionary = heatwaves[site]    dates = ta_HH[ta_HH['Site']==site].TIMESTAMP_START    TA = ta_HH[ta_HH['Site']==site].TA_F    TA_QAQC = ta_HH[ta_HH['Site']==site].TA_F_QC    # Use function to find if heatwaves have sufficient levels of ERA dowscaled data    site_check = minmax_QAQC_check(site_heatwave_dictionary, dates, TA, TA_QAQC, heatwave_threshold = .5, method='max')    # If theres actually valid data, then create site column and concat with other heatwave flags    if site_check is None:        continue    else:        site_check['Site'] = [site] * site_check.shape[0]        # Concat with the other site dataframes        heatwaves_qaqc = pd.concat([heatwaves_qaqc,site_check])    # Find those invalid heatwavesinvalid_heatwaves = heatwaves_qaqc[heatwaves_qaqc['QAQC_flag']==1]invalid_heatwaves = invalid_heatwaves[['Site','start_dates','end_dates']]invalid_heatwaves.columns = ['Site','start_date','end_date']# Now remove these heatwavesheatwaves = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves, invalid_heatwaves = invalid_heatwaves)# Create a dataframe of all precip conditionsall_precip = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site','Duration'])for site in heatwaves.keys():    # Pull out moisture for the site    site_data = heatwaves[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves[site]['summary'].duration    # Concat site data with all other data    all_precip = pd.concat([all_precip,site_data])    # Same for all SWC conditionsall_swc = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site'])for site in heatwaves.keys():    # Pull out moisture for the site    site_data = heatwaves[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc = pd.concat([all_swc,site_data])all_swc = all_swc.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_max.pkl","wb") as f:    pickle.dump(heatwaves, f)    # Save moisture as a csvall_precip.to_csv("max_precip.csv")all_swc.to_csv("max_swc.csv")# Save invalid heatwaves as wellinvalid_heatwaves.to_csv("invalid_heatwaves_max.csv")#################################################################################                              MEAN                                         ################################################################################## Defining heatwaves based on a mean daily temperature and its historical thresholdheatwaves_mean = {}for site in swc_data.Site.unique():    # Isolate site of interest in climatological and AMF data    # Temporarily changing historical data to be the timeseries data so I can get    # a rough estimate of the moisture conditions during the heatwaves    historical_site_data = historical_data[historical_data['Site']==site]    flux_data = AMF_DD[AMF_DD['Site']==site].copy()    site_precip = prec_data[prec_data['Site']==site].copy()    site_swc = swc_data[swc_data['Site']==site].copy()        # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(                      flux_dates = flux_data.date, # should be daily                      flux_temperature = flux_data.TA_F, # should be daily                      historical_dates = historical_site_data.date,                      historical_temperature = historical_site_data.hist_mean_adj,                      quantile_threshold = .97,                      window_length = 15,                      threshold_comparison = 'greater',                      min_heatwave_length = 3,                      tolerance = 1,                      gap_days_window = 8,                      site = site,                      method = "mean"                      )        # If there are no heatwaves because of invlaid data, move on    if site_heatwaves is None:        continue        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC_F_MDS_1,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        # Add heatwaves into a dictionary with their site    heatwaves_mean[site] = site_heatwaves    heatwaves_mean[site]['precip'] = site_heatwave_precip    heatwaves_mean[site]['swc'] = site_heatwave_swc    # Now we quality check the heatwaves# Initialize dataframe to store all heatwave quality checksheatwave_QAQC = pd.DataFrame(columns=['Site','start_date','end_date','QAQC_percentage','heatwave_invalidity'])for site in list(heatwaves_mean.keys()):    # Pull out that sites heatwaves from the heatwave dictionary    site_heatwave_dictionary = heatwaves_mean[site]    # Pull out that sites temperature QAQC dates and values    dates = ta[ta['Site']==site].TIMESTAMP    TA_QAQC = ta[ta['Site']==site].TA_F_QC    # Use the heatwave validity check function to get a dataframe of heatwave validity    site_QAQC = avg_QAQC_check(site_heatwave_dictionary, dates, TA_QAQC,                               QAQC_threshold=.5,heatwave_threshold=.75)    # If heatwaves weren't defined due to data issues, return nothing    if site_QAQC is None:        continue    # Add the site onto this dataframe    site_QAQC['Site'] = [site] * site_QAQC.shape[0]    # Concat with the other sites invalidity dataframes    heatwave_QAQC = pd.concat([heatwave_QAQC,site_QAQC])    # Isolate the heatwaves that are flagged as invalid# I got 46 of theseinvalid_heatwaves_mean = heatwave_QAQC[heatwave_QAQC['heatwave_invalidity']==1]invalid_heatwaves_mean = invalid_heatwaves_mean[['Site','start_date','end_date']]# Remove from the heatwave dictionaryheatwaves_mean = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves_mean, invalid_heatwaves = invalid_heatwaves_mean)# Create a dataframe of all precip conditionsall_precip_mean = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','moisture_variability','Site','Duration'])for site in heatwaves_mean.keys():    # Pull out moisture for the site    site_data = heatwaves_mean[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves_mean[site]['summary'].duration    # Concat site data with all other data    all_precip_mean = pd.concat([all_precip_mean,site_data])    # Same for all SWC conditionsall_swc_mean = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','moisture_variability','Site'])for site in heatwaves_mean.keys():    # Pull out moisture for the site    site_data = heatwaves_mean[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc_mean = pd.concat([all_swc_mean,site_data])all_swc_mean = all_swc_mean.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_mean.pkl","wb") as f:    pickle.dump(heatwaves_mean, f)    # Save moisture data as csvall_precip_mean.to_csv("mean_precip.csv")all_swc_mean.to_csv("mean_swc.csv")# Saving invalid heatwaves as wellinvalid_heatwaves.to_csv("invalid_heatwaves_mean.csv")#################################################################################                               Minimum                                     #################################################################################'''The code below implements the Pezza 2012 heatwave defining approach. This approachuses a 3 day running maximum and minimum temperature threshold to determine heatwaves. '''# Initialize empty dictionaryheatwaves_min = {}for site in swc_data.Site.unique():    flux_data = AMF_HH[AMF_HH['Site']==site]    # Isolate site of interest in climatological and AMF data    historical_site_data = historical_data[historical_data['Site']==site]    site_precip = prec_data[prec_data['Site']==site]    site_swc = swc_data[swc_data['Site']==site]        print(f"I'm currently on site {site}.")    # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(        flux_dates = flux_data.TIMESTAMP_START,         flux_temperature = flux_data.TA_F,         historical_dates = historical_site_data.date,         historical_temperature = historical_site_data.hist_min_adj,        quantile_threshold = .97,        min_heatwave_length = 3,        tolerance=1,        gap_days_window=8,        site = site,        method = 'min'        )        # If there are no heatwaves because of invalid data, just move on    if site_heatwaves is None:        continue        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC_F_MDS_1,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        # Add heatwaves into a dictionary with their site    heatwaves_min[site] = site_heatwaves    heatwaves_min[site]['precip'] = site_heatwave_precip    heatwaves_min[site]['swc'] = site_heatwave_swc    # Create a dataframe of the quality flag for each heatwave at each siteheatwaves_qaqc = pd.DataFrame(columns=['start_dates','end_dates','duration','magnitude','QAQC_flag'])for site in list(heatwaves_min.keys()):    print(site)    # Retrieve the heatwave dictionary for that site    site_heatwave_dictionary = heatwaves_min[site]    dates = ta_HH[ta_HH['Site']==site].TIMESTAMP_START    TA = ta_HH[ta_HH['Site']==site].TA_F    TA_QAQC = ta_HH[ta_HH['Site']==site].TA_F_QC    # Use function to find if heatwaves have sufficient levels of ERA dowscaled data    site_check = minmax_QAQC_check(site_heatwave_dictionary, dates, TA, TA_QAQC, heatwave_threshold = .75, method='min')    if site_check is None:        continue    # Add the site onto this dataframe    site_check['Site'] = [site] * site_check.shape[0]    # Concat with the other site dataframes    heatwaves_qaqc = pd.concat([heatwaves_qaqc,site_check])    # Find those invalid heatwavesinvalid_heatwaves_min = heatwaves_qaqc[heatwaves_qaqc['QAQC_flag']==1]invalid_heatwaves_min = invalid_heatwaves_min[['Site','start_dates','end_dates']]invalid_heatwaves_min.columns = ['Site','start_date','end_date']# Now remove these heatwavesheatwaves_min = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves_min, invalid_heatwaves = invalid_heatwaves_min)# Create a dataframe of all precip conditionsall_precip_min = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site','Duration'])for site in heatwaves_min.keys():    # Pull out moisture for the site    site_data = heatwaves_min[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves_min[site]['summary'].duration    # Concat site data with all other data    all_precip_min = pd.concat([all_precip_min,site_data])    # Same for all SWC conditionsall_swc_min = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site'])for site in heatwaves_min.keys():    # Pull out moisture for the site    site_data = heatwaves_min[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc_min = pd.concat([all_swc_min,site_data])all_swc_min = all_swc_min.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_min.pkl","wb") as f:    pickle.dump(heatwaves_min, f)# Save moisture data as a csvall_precip_min.to_csv("min_precip.csv")all_swc_min.to_csv("min_swc.csv")# Save invalid heatwave dataframe as a csvinvalid_heatwaves_min.to_csv("invalid_heatwaves_min.csv")#################################################################################                Unpacking heatwaves into dataframe                         ################################################################################## Find sites that have definitions for each type of heatwavemax_sites = list(heatwaves.keys())mean_sites = list(heatwaves_mean.keys())min_sites = list(heatwaves_min.keys())# Unpack the maximum heatwavesheatwaves_df = pd.DataFrame(columns=['Site','Method','start_dates','end_dates','duration','QAQC_flag'])for site in max_sites:    site_df = heatwaves[site]['summary']    site_df['Method'] = 'Max'    heatwaves_df = pd.concat([heatwaves_df,site_df])    # Unpack mean heatwavesfor site in mean_sites:    site_df = heatwaves_mean[site]['summary']    site_df['Site'] = [site] * len(heatwaves_mean[site]['summary'])    site_df['Method'] = 'Mean'    heatwaves_df = pd.concat([heatwaves_df,site_df])    # Unpack minimum heatwavesfor site in min_sites:    site_df = heatwaves_min[site]['summary']    site_df['Method'] = 'Min'    site_df['Site'] = site    site_df['QAQC_flag'] = np.nan    heatwaves_df = pd.concat([heatwaves_df,site_df])    heatwaves_df.to_csv("/Users/marleeyork/Documents/project2/data/heatwaves/heatwaves_df.csv")#################################################################################                         Combining the heatwaves                           #################################################################################max_sites = list(heatwaves.keys())min_sites = list(heatwaves_min.keys())mean_sites = list(heatwaves_mean.keys())all_sites = list(set(max_sites) & set(min_sites) & set(mean_sites))# Isolate heatwaves that are fit across all 3 measurementsreduced_heatwaves = {k: heatwaves[k] for k in all_sites if k in heatwaves}reduced_heatwaves_min = {k: heatwaves_min[k] for k in all_sites if k in heatwaves_min}reduced_heatwaves_mean = {k: heatwaves_mean[k] for k in all_sites if k in heatwaves_mean}# Calculate the heatwave overlapall_heatwaves = find_heatwave_overlap(min_heatwaves = reduced_heatwaves_min,                      max_heatwaves = reduced_heatwaves,                      avg_heatwaves = reduced_heatwaves_mean                      )# Save the dictionary as a pickle# Currently, this is 100 sitesos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("all_heatwaves.pkl","wb") as f:    pickle.dump(all_heatwaves, f)# Unpacking all heatwaves and organizing into dataframe by site# Initialize a dataframe to store heatwavesall_heatwaves_df = pd.DataFrame(columns=['Site','start_dates','end_dates','top_heatwave'])# Loop through each sitefor site in list(all_heatwaves.keys()):    # Pull the sites heatwaves from the dictionary of overlapping heatwaves    this_site_heatwaves = all_heatwaves[site]['heatwave_type']    # Add a site column    this_site_heatwaves['Site'] = [site] * this_site_heatwaves.shape[0]    # Concat with the other sites dataframe    all_heatwaves_df = pd.concat([all_heatwaves_df, this_site_heatwaves])    # Merge with IGBP (loaded this in the moisture section)all_heatwaves_df = pd.merge(all_heatwaves_df,IGBP,on='Site',how='left').drop_duplicates()# Isolate the month from the start dateall_heatwaves_df['Month'] = all_heatwaves_df['start_dates'].dt.month# Create a season variable from the monthseason = []for i in range(all_heatwaves_df.shape[0]):    month = all_heatwaves_df.iloc[i]['Month']    if (3 <= month <= 5):        season.append('Spring')    elif (6 <= month <= 8):        season.append('Summer')    elif (9 <= month <= 11):        season.append('Fall')    else:        season.append('Winter')all_heatwaves_df['Season'] = season# Find the swc data for each siteall_moisture = pd.DataFrame(columns=['Site','start_dates','end_dates',                                     'prec_average','prec_total','prec_variability',                                     'swc_average','swc_total','swc_variability'])for site in all_heatwaves.keys():    print(site)    # Pull the swc, prec, and heatwave data for the site    site_swc = swc_data[swc_data['Site']==site]    site_prec = prec_data[prec_data['Site']==site]    site_heatwaves = all_heatwaves_df[all_heatwaves_df['Site']==site]    # Calculate the swc values and replace any less than 0 with NA    heatwave_swc = calculate_moisture(timeseries_dates=site_swc.TIMESTAMP,                                      timeseries_moisture=site_swc.SWC_F_MDS_1,                                      start_dates=site_heatwaves.start_dates,                                      end_dates=site_heatwaves.end_dates)    heatwave_swc.columns = ['start_dates','end_dates','swc_average','swc_total','swc_variability']    mask = heatwave_swc['swc_total'] < 0    heatwave_swc.loc[mask, ['swc_average', 'swc_total', 'swc_variability']] = np.nan    # Doing the same for precipitation data now    heatwave_prec = calculate_moisture(timeseries_dates=site_prec.TIMESTAMP,                                       timeseries_moisture=site_prec.P_F,                                       start_dates=site_heatwaves.start_dates,                                       end_dates=site_heatwaves.end_dates)    heatwave_prec.columns = ['start_dates','end_dates','prec_average','prec_total','prec_variability']    mask = heatwave_prec['prec_total'] < 0    heatwave_prec.loc[mask, ['prec_average','prec_total','prec_variability']] = np.nan    # Merge swc and prec data together    site_heatwave_moisture = pd.merge(heatwave_prec,heatwave_swc,on=['start_dates','end_dates'],how='inner')    site_heatwave_moisture['Site'] = [site] * len(site_heatwave_moisture)    # Concat site data with other sites    all_moisture = pd.concat([all_moisture,site_heatwave_moisture])# Merge with the rest of the heatwave dataall_heatwaves_df = pd.merge(all_heatwaves_df, all_moisture, on=['Site','start_dates','end_dates'],how='left')# Adding in a heatwave duration columnall_heatwaves_df['duration'] = all_heatwaves_df.end_dates - all_heatwaves_df.start_dates   all_heatwaves_df['duration'] = all_heatwaves_df['duration'].dt.days + 1# Drop anything less than 3 days (there should be none)all_heatwaves_df = all_heatwaves_df[all_heatwaves_df['duration'] > 2]# Write this to a csvall_heatwaves_df.to_csv("/Users/marleeyork/Documents/project2/data/heatwaves/all_heatwaves_df.csv")